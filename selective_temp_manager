"""
SeÃ§ici Temp Dosya YÃ¶neticisi
Sadece HTML tarayÄ±cÄ± raporlarÄ± ve Word okuma hatasÄ± temp dosyalarÄ±nÄ± yÃ¶netir
Normal rapor sistemi deÄŸiÅŸmez
"""
import os
import tempfile
import atexit
import shutil
import glob
import threading
import time
from pathlib import Path
from typing import Set
import datetime

class SelectiveTempManager:
    """Sadece belirli temp dosya tÃ¼rlerini yÃ¶neten sÄ±nÄ±f"""
    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(SelectiveTempManager, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            # Sadece belirli kategoriler iÃ§in temp takibi
            self.browser_temp_files: Set[str] = set()  # HTML tarayÄ±cÄ± dosyalarÄ±
            self.word_error_temp_files: Set[str] = set()  # Word okuma hatasÄ± temp dosyalarÄ±
            self.cleanup_registered = False
            
            # Program baÅŸlatÄ±ldÄ±ÄŸÄ±nda eski temp dosyalarÄ± temizle
            self._cleanup_old_browser_temps()
            
            # Program kapatÄ±lÄ±rken temizlik kaydet
            self._register_cleanup()
            
            self.initialized = True
            print("ğŸ¯ SeÃ§ici Temp YÃ¶neticisi baÅŸlatÄ±ldÄ± (sadece tarayÄ±cÄ± ve Word hata dosyalarÄ±)")
    
    def _register_cleanup(self):
        """Program kapatÄ±lÄ±rken temizlik fonksiyonunu kaydet"""
        if not self.cleanup_registered:
            atexit.register(self.cleanup_selective_temps)
            self.cleanup_registered = True
    
    def _cleanup_old_browser_temps(self):
        """Program baÅŸlatÄ±lÄ±rken eski tarayÄ±cÄ± temp dosyalarÄ±nÄ± temizle"""
        try:
            temp_dir = tempfile.gettempdir()
            
            # Sadece belirli prefix'leri temizle
            patterns = [
                "DigitalIRS_browser_*.html",
                "DigitalIRS_quick_report_*.html", 
                "DigitalIRS_word_fixed_*.docx",
                "DigitalIRS_headerless_*.docx"
            ]
            
            cleaned_count = 0
            for pattern in patterns:
                full_pattern = os.path.join(temp_dir, pattern)
                old_files = glob.glob(full_pattern)
                
                for file_path in old_files:
                    try:
                        if os.path.isfile(file_path) and self._is_file_old(file_path, hours=24):
                            os.remove(file_path)
                            cleaned_count += 1
                    except Exception as e:
                        print(f"âš  Eski temp dosyasÄ± silinemedi {file_path}: {e}")
            
            if cleaned_count > 0:
                print(f"ğŸ§¹ {cleaned_count} eski tarayÄ±cÄ±/Word temp dosyasÄ± temizlendi")
                
        except Exception as e:
            print(f"âš  Eski temp temizleme hatasÄ±: {e}")
    
    def _is_file_old(self, file_path: str, hours: int = 24) -> bool:
        """DosyanÄ±n belirtilen saatten eski olup olmadÄ±ÄŸÄ±nÄ± kontrol eder"""
        try:
            file_time = os.path.getmtime(file_path)
            current_time = time.time()
            return (current_time - file_time) > (hours * 3600)
        except:
            return False
    
    def create_browser_temp_file(self, content: str, suffix: str = ".html") -> str:
        """TarayÄ±cÄ±da aÃ§Ä±lacak HTML dosyasÄ± iÃ§in temp dosya oluÅŸtur"""
        try:
            with tempfile.NamedTemporaryFile(
                mode='w', 
                suffix=suffix, 
                prefix='DigitalIRS_browser_', 
                delete=False,
                encoding='utf-8'
            ) as temp_file:
                temp_path = temp_file.name
                temp_file.write(content)
            
            self.browser_temp_files.add(temp_path)
            print(f"ğŸŒ TarayÄ±cÄ± temp dosyasÄ± oluÅŸturuldu: {os.path.basename(temp_path)}")
            return temp_path
            
        except Exception as e:
            print(f"HATA: TarayÄ±cÄ± temp dosya oluÅŸturma hatasÄ±: {e}")
            raise
    
    def register_word_error_temp(self, file_path: str):
        """Word okuma hatasÄ± iÃ§in oluÅŸturulan temp dosyasÄ±nÄ± kaydet"""
        if os.path.exists(file_path):
            self.word_error_temp_files.add(file_path)
            print(f"ğŸ“„ Word hata temp dosyasÄ± kaydedildi: {os.path.basename(file_path)}")
    
    def create_word_error_temp(self, suffix: str = ".docx", prefix: str = "word_fixed_") -> str:
        """Word okuma hatasÄ± iÃ§in temp dosya oluÅŸtur"""
        try:
            with tempfile.NamedTemporaryFile(
                suffix=suffix, 
                prefix=f'DigitalIRS_{prefix}', 
                delete=False
            ) as temp_file:
                temp_path = temp_file.name
            
            self.word_error_temp_files.add(temp_path)
            print(f"ğŸ”§ Word hata temp dosyasÄ± oluÅŸturuldu: {os.path.basename(temp_path)}")
            return temp_path
            
        except Exception as e:
            print(f"HATA: Word hata temp dosya oluÅŸturma hatasÄ±: {e}")
            raise
    
    def cleanup_selective_temps(self):
        """Sadece seÃ§ili temp dosyalarÄ± temizle"""
        print("ğŸ¯ SeÃ§ici temp dosya temizliÄŸi baÅŸlatÄ±lÄ±yor...")
        
        cleaned_browser = 0
        cleaned_word_error = 0
        
        # TarayÄ±cÄ± temp dosyalarÄ±nÄ± temizle
        for file_path in list(self.browser_temp_files):
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    cleaned_browser += 1
                    print(f"ğŸ—‘ï¸ TarayÄ±cÄ± temp silindi: {os.path.basename(file_path)}")
                self.browser_temp_files.remove(file_path)
            except Exception as e:
                print(f"âš  TarayÄ±cÄ± temp silinemedi {file_path}: {e}")
        
        # Word hata temp dosyalarÄ±nÄ± temizle
        for file_path in list(self.word_error_temp_files):
            try:
                if os.path.exists(file_path):
                    os.remove(file_path)
                    cleaned_word_error += 1
                    print(f"ğŸ—‘ï¸ Word hata temp silindi: {os.path.basename(file_path)}")
                self.word_error_temp_files.remove(file_path)
            except Exception as e:
                print(f"âš  Word hata temp silinemedi {file_path}: {e}")
        
        total_cleaned = cleaned_browser + cleaned_word_error
        if total_cleaned > 0:
            print(f"âœ… SeÃ§ici temp temizlik tamamlandÄ±: {cleaned_browser} tarayÄ±cÄ±, {cleaned_word_error} Word hata dosyasÄ±")
        else:
            print("âœ… Temizlenecek temp dosyasÄ± bulunamadÄ±")
    
    def get_temp_status(self) -> dict:
        """Temp dosya durumunu dÃ¶ner"""
        browser_size = 0
        word_error_size = 0
        browser_existing = 0
        word_error_existing = 0
        
        # TarayÄ±cÄ± dosyalarÄ±nÄ± kontrol et
        for file_path in self.browser_temp_files:
            if os.path.exists(file_path):
                try:
                    browser_size += os.path.getsize(file_path)
                    browser_existing += 1
                except:
                    pass
        
        # Word hata dosyalarÄ±nÄ± kontrol et
        for file_path in self.word_error_temp_files:
            if os.path.exists(file_path):
                try:
                    word_error_size += os.path.getsize(file_path)
                    word_error_existing += 1
                except:
                    pass
        
        return {
            'browser_files_total': len(self.browser_temp_files),
            'browser_files_existing': browser_existing,
            'browser_size_mb': browser_size / (1024 * 1024),
            'word_error_files_total': len(self.word_error_temp_files),
            'word_error_files_existing': word_error_existing,
            'word_error_size_mb': word_error_size / (1024 * 1024),
            'total_size_mb': (browser_size + word_error_size) / (1024 * 1024),
            'temp_directory': tempfile.gettempdir()
        }

# Singleton instance
selective_temp_manager = SelectiveTempManager()

# HeaderlessWordReader'Ä± gÃ¼ncelleyin
class UpdatedHeaderlessWordReader:
    """Header/Footer'sÄ±z Word okuyucu - seÃ§ici temp yÃ¶netimi ile"""
    
    def __init__(self):
        self.current_document = None
        self.raw_xml_content = None
        self.temp_manager = selective_temp_manager
    
    def load_document_without_headers(self, file_path: str) -> bool:
        """Word dosyasÄ±nÄ± header/footer'lar olmadan yÃ¼kler"""
        try:
            print(f"Header/Footer'sÄ±z Word yÃ¼kleme deneniyor: {file_path}")
            
            # Ã–nce normal yÃ¼klemeyi dene
            try:
                from docx import Document
                doc = Document(file_path)
                self.current_document = doc
                print(f"âœ“ Normal Word dosyasÄ± yÃ¼klendi: {file_path}")
                return True
            except Exception as normal_error:
                print(f"âš  Normal yÃ¼kleme baÅŸarÄ±sÄ±z: {normal_error}")
                
                # Header/footer hatasÄ± mÄ± kontrol et
                error_msg = str(normal_error).lower()
                if any(keyword in error_msg for keyword in ['header', 'footer', 'relationship', 'null']):
                    print("ğŸ”§ Header/Footer corruption tespit edildi, headerless yÃ¼kleme deneniyor...")
                    return self._load_without_problematic_parts(file_path)
                else:
                    print(f"HATA: Bilinmeyen Word hatasÄ±: {normal_error}")
                    return False
                    
        except Exception as e:
            print(f"HATA: Genel Word yÃ¼kleme hatasÄ±: {e}")
            return False

    def _load_without_problematic_parts(self, file_path: str) -> bool:
        """Problematik header/footer'larÄ± temizleyerek yÃ¼kle"""
        try:
            # Temp dosya oluÅŸtur - seÃ§ici temp yÃ¶neticisi ile
            temp_path = self.temp_manager.create_word_error_temp(suffix='.docx', prefix='headerless_')
            
            try:
                # DOCX dosyasÄ±nÄ± ZIP olarak aÃ§ ve temizle
                success = self._create_clean_docx(file_path, temp_path)
                
                if success:
                    # TemizlenmiÅŸ dosyayÄ± yÃ¼kle
                    from docx import Document
                    doc = Document(temp_path)
                    self.current_document = doc
                    print(f"âœ“ Headerless Word dosyasÄ± baÅŸarÄ±yla yÃ¼klendi")
                    return True
                else:
                    # Son Ã§are: XML'i direkt oku
                    return self._load_from_raw_xml(file_path)
                    
            except Exception as load_error:
                print(f"TemizlenmiÅŸ dosya yÃ¼kleme hatasÄ±: {load_error}")
                # Son Ã§are: XML'i direkt oku
                return self._load_from_raw_xml(file_path)
                    
        except Exception as e:
            print(f"HATA: Headerless yÃ¼kleme hatasÄ±: {e}")
            return self._load_from_raw_xml(file_path)

    def _create_clean_docx(self, input_path: str, output_path: str) -> bool:
        """Header/Footer'larÄ± temizlenmiÅŸ DOCX oluÅŸtur"""
        try:
            import zipfile
            
            with zipfile.ZipFile(input_path, 'r') as zip_in:
                with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zip_out:
                    
                    for item in zip_in.infolist():
                        # Problematik dosyalarÄ± atla
                        if self._should_skip_file(item.filename):
                            print(f"    AtlanÄ±yor: {item.filename}")
                            continue
                        
                        # Relationship dosyalarÄ±nÄ± temizle
                        if item.filename.endswith('.rels'):
                            cleaned_content = self._clean_rels_content(zip_in.read(item))
                            if cleaned_content:
                                zip_out.writestr(item, cleaned_content)
                            else:
                                print(f"    BoÅŸ rels dosyasÄ± atlandÄ±: {item.filename}")
                        else:
                            # Normal dosyalarÄ± kopyala
                            zip_out.writestr(item, zip_in.read(item))
            
            print("âœ“ TemizlenmiÅŸ DOCX oluÅŸturuldu")
            return True
            
        except Exception as e:
            print(f"HATA: Clean DOCX oluÅŸturma hatasÄ±: {e}")
            return False

    def _should_skip_file(self, filename: str) -> bool:
        """Hangi dosyalarÄ±n atlanacaÄŸÄ±nÄ± belirler"""
        skip_patterns = [
            'word/header',
            'word/footer', 
            'word/endnotes.xml',
            'word/footnotes.xml',
            'word/comments.xml',
            'word/webSettings.xml'
        ]
        
        filename_lower = filename.lower()
        return any(pattern in filename_lower for pattern in skip_patterns)

    def _clean_rels_content(self, rels_content: bytes) -> bytes:
        """Relationship iÃ§eriÄŸini temizler"""
        try:
            content_str = rels_content.decode('utf-8')
            
            lines = content_str.split('\n')
            cleaned_lines = []
            
            for line in lines:
                if (any(bad_ref in line for bad_ref in ['../NULL', '"NULL"', 'header', 'footer']) or
                    'Target="#_' in line):
                    print(f"      Problematik rels satÄ±rÄ± temizlendi")
                    continue
                cleaned_lines.append(line)
            
            return '\n'.join(cleaned_lines).encode('utf-8')
            
        except Exception as e:
            print(f"UYARI: Rels temizleme hatasÄ±: {e}")
            return rels_content

    def _load_from_raw_xml(self, file_path: str) -> bool:
        """Son Ã§are: Raw XML'den document.xml'i oku"""
        try:
            print("ğŸ“„ Son Ã§are: Raw XML okuma deneniyor...")
            
            import zipfile
            import xml.etree.ElementTree as ET
            
            with zipfile.ZipFile(file_path, 'r') as zip_file:
                try:
                    document_xml = zip_file.read('word/document.xml')
                    self.raw_xml_content = document_xml.decode('utf-8')
                    
                    # Basit Document objesi oluÅŸtur (sadece tablolar iÃ§in)
                    self.current_document = self._create_minimal_document(document_xml)
                    
                    print("âœ“ Raw XML'den minimal document oluÅŸturuldu")
                    return True
                    
                except KeyError:
                    print("HATA: document.xml bulunamadÄ±")
                    return False
                    
        except Exception as e:
            print(f"HATA: Raw XML okuma hatasÄ±: {e}")
            return False

    def _create_minimal_document(self, document_xml: bytes):
        """Minimal Document objesi oluÅŸtur (sadece tablolar iÃ§in)"""
        try:
            import xml.etree.ElementTree as ET
            
            root = ET.fromstring(document_xml)
            
            namespaces = {
                'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
            }
            
            tables = root.findall('.//w:tbl', namespaces)
            print(f"Raw XML'de {len(tables)} tablo bulundu")
            
            class MinimalDocument:
                def __init__(self, table_elements):
                    self.tables = [MinimalTable(tbl, namespaces) for tbl in table_elements]
            
            return MinimalDocument(tables)
            
        except Exception as e:
            print(f"HATA: Minimal document oluÅŸturma hatasÄ±: {e}")
            return None

class MinimalTable:
    """Raw XML'den minimal tablo objesi"""
    
    def __init__(self, table_element, namespaces):
        self.rows = []
        self._parse_table(table_element, namespaces)
    
    def _parse_table(self, table_element, namespaces):
        """Tablo elementini parse et"""
        try:
            row_elements = table_element.findall('.//w:tr', namespaces)
            
            for row_elem in row_elements:
                cells = []
                cell_elements = row_elem.findall('.//w:tc', namespaces)
                
                for cell_elem in cell_elements:
                    text_elements = cell_elem.findall('.//w:t', namespaces)
                    cell_text = ''.join([t.text or '' for t in text_elements])
                    cells.append(MinimalCell(cell_text))
                
                if cells:
                    self.rows.append(MinimalRow(cells))
                    
        except Exception as e:
            print(f"UYARI: Tablo parse hatasÄ±: {e}")

class MinimalRow:
    """Minimal satÄ±r objesi"""
    def __init__(self, cells):
        self.cells = cells

class MinimalCell:
    """Minimal hÃ¼cre objesi"""
    def __init__(self, text):
        self.text = text
        self.paragraphs = [MinimalParagraph(text)]

class MinimalParagraph:
    """Minimal paragraf objesi"""
    def __init__(self, text):
        self.text = text

# Lot Report Generator iÃ§in browser temp fonksiyonu
def create_browser_html_report(content: str, title: str = "Rapor") -> str:
    """TarayÄ±cÄ±da aÃ§Ä±lacak HTML raporu oluÅŸtur (seÃ§ici temp ile)"""
    html_template = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>{title}</title>
    <style>
        body {{ font-family: Arial; margin: 20px; }}
        .header {{ background: #f0f0f0; padding: 15px; border-radius: 8px; }}
        .content {{ padding: 20px; }}
        .temp-warning {{ 
            background: #fff3cd; 
            border: 1px solid #ffeaa7; 
            padding: 10px; 
            border-radius: 5px; 
            margin: 10px 0;
            color: #856404;
        }}
    </style>
</head>
<body>
    <div class="temp-warning">
        âš ï¸ Bu dosya geÃ§ici klasÃ¶rdedir ve program kapatÄ±lÄ±rken otomatik silinecektir.
    </div>
    <div class="header">
        <h1>{title}</h1>
        <p>OluÅŸturulma: {datetime.datetime.now().strftime('%d.%m.%Y %H:%M:%S')}</p>
    </div>
    <div class="content">
        {content}
    </div>
</body>
</html>
    """
    
    return selective_temp_manager.create_browser_temp_file(html_template)

def open_temp_file_in_browser(file_path: str):
    """Temp dosyasÄ±nÄ± tarayÄ±cÄ±da aÃ§"""
    try:
        import webbrowser
        webbrowser.open(f'file://{os.path.abspath(file_path)}')
        print(f"ğŸŒ Temp dosya tarayÄ±cÄ±da aÃ§Ä±ldÄ±: {os.path.basename(file_path)}")
    except Exception as e:
        print(f"HATA: TarayÄ±cÄ±da aÃ§ma hatasÄ±: {e}")

# Ana uygulamaya entegrasyon iÃ§in
class EnhancedMainWindowWithSelectiveTemp:
    """Ana pencere - seÃ§ici temp temizlik ile"""
    
    def __init__(self):
        # ... mevcut init kodlarÄ± deÄŸiÅŸmez ...
        self.selective_temp_manager = selective_temp_manager
        
        # Pencere kapatma event'ini ayarla
        self.protocol("WM_DELETE_WINDOW", self.on_closing_with_selective_temp_cleanup)
        
        print("ğŸ¯ Ana pencere seÃ§ici temp yÃ¶netimi ile baÅŸlatÄ±ldÄ±")
    
    def on_closing_with_selective_temp_cleanup(self):
        """Pencere kapatÄ±lÄ±rken seÃ§ici temp temizlik ile"""
        try:
            print("ğŸ”„ Program kapatÄ±lÄ±yor, temp dosyalar kontrol ediliyor...")
            
            # Temp bilgilerini al
            temp_status = self.selective_temp_manager.get_temp_status()
            
            total_existing = temp_status['browser_files_existing'] + temp_status['word_error_files_existing']
            
            if total_existing > 0:
                print(f"ğŸ“Š Bulundu: {temp_status['browser_files_existing']} tarayÄ±cÄ±, {temp_status['word_error_files_existing']} Word temp dosyasÄ± ({temp_status['total_size_mb']:.2f} MB)")
                
                # KullanÄ±cÄ±ya sor (opsiyonel)
                try:
                    from tkinter import messagebox
                    response = messagebox.askyesno(
                        "GeÃ§ici Dosya TemizliÄŸi", 
                        f"Program tarafÄ±ndan oluÅŸturulan geÃ§ici dosyalar:\n\n"
                        f"ğŸŒ {temp_status['browser_files_existing']} tarayÄ±cÄ± raporu\n"
                        f"ğŸ“„ {temp_status['word_error_files_existing']} Word dÃ¼zeltme dosyasÄ±\n"
                        f"ğŸ’¾ Toplam: {temp_status['total_size_mb']:.2f} MB\n\n"
                        f"Bu dosyalar silinsin mi?\n"
                        f"(Normal raporlarÄ±nÄ±z silinmeyecektir)"
                    )
                    
                    if response:
                        self.selective_temp_manager.cleanup_selective_temps()
                        print("âœ… KullanÄ±cÄ± onayÄ± ile seÃ§ici temp dosyalar temizlendi")
                    else:
                        print("âš  KullanÄ±cÄ± temp temizliÄŸi iptal etti")
                        
                except Exception as dialog_error:
                    print(f"Dialog hatasÄ±: {dialog_error}")
                    # Dialog baÅŸarÄ±sÄ±zsa otomatik temizle
                    self.selective_temp_manager.cleanup_selective_temps()
                    print("âœ… Dialog hatasÄ± nedeniyle otomatik temizlendi")
            else:
                print("âœ… Temizlenecek temp dosyasÄ± yok")
            
            # DiÄŸer temizlik iÅŸlemleri (deÄŸiÅŸmez)
            self.perform_other_cleanup()
            
            # Pencereyi kapat
            self.destroy()
            
        except Exception as e:
            print(f"HATA: Kapatma sÄ±rasÄ±nda hata: {e}")
            try:
                self.destroy()
            except:
                import sys
                sys.exit()

# Test fonksiyonu
def test_selective_temp_management():
    """SeÃ§ici temp yÃ¶netim sistemini test eder"""
    print("=== SELECTÄ°VE TEMP MANAGEMENT TEST ===")
    
    # Test tarayÄ±cÄ± HTML dosyasÄ± oluÅŸtur
    html_content = "<h2>Test HTML raporu</h2><p>Bu bir test tarayÄ±cÄ± iÃ§eriÄŸidir.</p>"
    browser_file = create_browser_html_report(html_content, "Test TarayÄ±cÄ± Raporu")
    
    # Test Word hata dosyasÄ± oluÅŸtur
    word_error_file = selective_temp_manager.create_word_error_temp()
    
    # Durum gÃ¶ster
    status = selective_temp_manager.get_temp_status()
    print(f"""
ğŸ¯ SELECTÄ°VE TEMP DURUMU:
  ğŸŒ TarayÄ±cÄ± dosyalarÄ±: {status['browser_files_existing']}/{status['browser_files_total']} ({status['browser_size_mb']:.2f} MB)
  ğŸ“„ Word hata dosyalarÄ±: {status['word_error_files_existing']}/{status['word_error_files_total']} ({status['word_error_size_mb']:.2f} MB)
  ğŸ’¾ Toplam boyut: {status['total_size_mb']:.2f} MB
    """)
    
    # TarayÄ±cÄ±da aÃ§
    open_temp_file_in_browser(browser_file)
    
    # 5 saniye sonra temizlik
    print("\n5 saniye sonra seÃ§ici temizlik yapÄ±lacak...")
    time.sleep(5)
    selective_temp_manager.cleanup_selective_temps()
    
    print("âœ… Test tamamlandÄ±")

if __name__ == "__main__":
    test_selective_temp_management()
