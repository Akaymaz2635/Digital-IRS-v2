"""
Header/Footer'sÄ±z Word dosyasÄ± okuma Ã§Ã¶zÃ¼mÃ¼
SharePoint corruption'Ä±nda header/footer'lar sorun yaratÄ±yorsa onlarÄ± atla
"""
import os
import tempfile
import zipfile
import xml.etree.ElementTree as ET
from docx import Document
from docx.document import Document as DocumentClass
from docx.oxml.document import CT_Document
from docx.oxml.parser import parse_xml
from typing import List

class HeaderlessWordReader:
    """Header/Footer olmadan Word dosyasÄ± okuyucu"""
    
    def __init__(self):
        self.current_document = None
        self.raw_xml_content = None

    def load_document_without_headers(self, file_path: str) -> bool:
        """Word dosyasÄ±nÄ± header/footer'lar olmadan yÃ¼kler"""
        try:
            print(f"Header/Footer'sÄ±z Word yÃ¼kleme deneniyor: {file_path}")
            
            # Ã–nce normal yÃ¼klemeyi dene
            try:
                doc = Document(file_path)
                self.current_document = doc
                print(f"âœ“ Normal Word dosyasÄ± yÃ¼klendi: {file_path}")
                return True
            except Exception as normal_error:
                print(f"âš  Normal yÃ¼kleme baÅŸarÄ±sÄ±z: {normal_error}")
                
                # Header/footer hatasÄ± mÄ± kontrol et
                error_msg = str(normal_error).lower()
                if any(keyword in error_msg for keyword in ['header', 'footer', 'relationship', 'null']):
                    print("ğŸ”§ Header/Footer corruption tespit edildi, headerless yÃ¼kleme deneniyor...")
                    return self._load_without_problematic_parts(file_path)
                else:
                    print(f"HATA: Bilinmeyen Word hatasÄ±: {normal_error}")
                    return False
                    
        except Exception as e:
            print(f"HATA: Genel Word yÃ¼kleme hatasÄ±: {e}")
            return False

    def _load_without_problematic_parts(self, file_path: str) -> bool:
        """Problematik header/footer'larÄ± temizleyerek yÃ¼kle"""
        try:
            # GeÃ§ici dosya oluÅŸtur
            with tempfile.NamedTemporaryFile(suffix='.docx', delete=False) as temp_file:
                temp_path = temp_file.name
            
            try:
                # DOCX dosyasÄ±nÄ± ZIP olarak aÃ§ ve temizle
                success = self._create_clean_docx(file_path, temp_path)
                
                if success:
                    # TemizlenmiÅŸ dosyayÄ± yÃ¼kle
                    doc = Document(temp_path)
                    self.current_document = doc
                    print(f"âœ“ Headerless Word dosyasÄ± baÅŸarÄ±yla yÃ¼klendi")
                    return True
                else:
                    # Son Ã§are: XML'i direkt oku
                    return self._load_from_raw_xml(file_path)
                    
            finally:
                # GeÃ§ici dosyayÄ± temizle
                try:
                    os.unlink(temp_path)
                except:
                    pass
                    
        except Exception as e:
            print(f"HATA: Headerless yÃ¼kleme hatasÄ±: {e}")
            return self._load_from_raw_xml(file_path)

    def _create_clean_docx(self, input_path: str, output_path: str) -> bool:
        """Header/Footer'larÄ± temizlenmiÅŸ DOCX oluÅŸtur"""
        try:
            with zipfile.ZipFile(input_path, 'r') as zip_in:
                with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zip_out:
                    
                    for item in zip_in.infolist():
                        # Problematik dosyalarÄ± atla
                        if self._should_skip_file(item.filename):
                            print(f"    AtlanÄ±yor: {item.filename}")
                            continue
                        
                        # Relationship dosyalarÄ±nÄ± temizle
                        if item.filename.endswith('.rels'):
                            cleaned_content = self._clean_rels_content(zip_in.read(item))
                            if cleaned_content:
                                zip_out.writestr(item, cleaned_content)
                            else:
                                print(f"    BoÅŸ rels dosyasÄ± atlandÄ±: {item.filename}")
                        else:
                            # Normal dosyalarÄ± kopyala
                            zip_out.writestr(item, zip_in.read(item))
            
            print("âœ“ TemizlenmiÅŸ DOCX oluÅŸturuldu")
            return True
            
        except Exception as e:
            print(f"HATA: Clean DOCX oluÅŸturma hatasÄ±: {e}")
            return False

    def _should_skip_file(self, filename: str) -> bool:
        """Hangi dosyalarÄ±n atlanacaÄŸÄ±nÄ± belirler"""
        skip_patterns = [
            'word/header',
            'word/footer', 
            'word/endnotes.xml',
            'word/footnotes.xml',
            'word/comments.xml',
            'word/webSettings.xml'
        ]
        
        filename_lower = filename.lower()
        return any(pattern in filename_lower for pattern in skip_patterns)

    def _clean_rels_content(self, rels_content: bytes) -> bytes:
        """Relationship iÃ§eriÄŸini temizler"""
        try:
            content_str = rels_content.decode('utf-8')
            
            # Problematik satÄ±rlarÄ± temizle
            lines = content_str.split('\n')
            cleaned_lines = []
            
            for line in lines:
                # NULL referanslarÄ± ve problematik relationship'leri atla
                if (any(bad_ref in line for bad_ref in ['../NULL', '"NULL"', 'header', 'footer']) or
                    'Target="#_' in line):
                    print(f"      Problematik rels satÄ±rÄ± temizlendi")
                    continue
                cleaned_lines.append(line)
            
            return '\n'.join(cleaned_lines).encode('utf-8')
            
        except Exception as e:
            print(f"UYARI: Rels temizleme hatasÄ±: {e}")
            return rels_content

    def _load_from_raw_xml(self, file_path: str) -> bool:
        """Son Ã§are: Raw XML'den document.xml'i oku"""
        try:
            print("ğŸ“„ Son Ã§are: Raw XML okuma deneniyor...")
            
            with zipfile.ZipFile(file_path, 'r') as zip_file:
                # document.xml'i oku
                try:
                    document_xml = zip_file.read('word/document.xml')
                    self.raw_xml_content = document_xml.decode('utf-8')
                    
                    # Basit Document objesi oluÅŸtur (sadece tablolar iÃ§in)
                    self.current_document = self._create_minimal_document(document_xml)
                    
                    print("âœ“ Raw XML'den minimal document oluÅŸturuldu")
                    return True
                    
                except KeyError:
                    print("HATA: document.xml bulunamadÄ±")
                    return False
                    
        except Exception as e:
            print(f"HATA: Raw XML okuma hatasÄ±: {e}")
            return False

    def _create_minimal_document(self, document_xml: bytes):
        """Minimal Document objesi oluÅŸtur (sadece tablolar iÃ§in)"""
        try:
            # XML'i parse et
            root = ET.fromstring(document_xml)
            
            # Namespace'leri tanÄ±mla
            namespaces = {
                'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
            }
            
            # Tablo elementlerini bul
            tables = root.findall('.//w:tbl', namespaces)
            print(f"Raw XML'de {len(tables)} tablo bulundu")
            
            # Minimal Document-like objesi oluÅŸtur
            class MinimalDocument:
                def __init__(self, table_elements):
                    self.tables = [MinimalTable(tbl, namespaces) for tbl in table_elements]
            
            return MinimalDocument(tables)
            
        except Exception as e:
            print(f"HATA: Minimal document oluÅŸturma hatasÄ±: {e}")
            return None

class MinimalTable:
    """Raw XML'den minimal tablo objesi"""
    
    def __init__(self, table_element, namespaces):
        self.rows = []
        self._parse_table(table_element, namespaces)
    
    def _parse_table(self, table_element, namespaces):
        """Tablo elementini parse et"""
        try:
            row_elements = table_element.findall('.//w:tr', namespaces)
            
            for row_elem in row_elements:
                cells = []
                cell_elements = row_elem.findall('.//w:tc', namespaces)
                
                for cell_elem in cell_elements:
                    # HÃ¼credeki text'i al
                    text_elements = cell_elem.findall('.//w:t', namespaces)
                    cell_text = ''.join([t.text or '' for t in text_elements])
                    cells.append(MinimalCell(cell_text))
                
                if cells:  # BoÅŸ satÄ±rlarÄ± atla
                    self.rows.append(MinimalRow(cells))
                    
        except Exception as e:
            print(f"UYARI: Tablo parse hatasÄ±: {e}")

class MinimalRow:
    """Minimal satÄ±r objesi"""
    def __init__(self, cells):
        self.cells = cells

class MinimalCell:
    """Minimal hÃ¼cre objesi"""
    def __init__(self, text):
        self.text = text
        # Paragraf simÃ¼lasyonu
        self.paragraphs = [MinimalParagraph(text)]

class MinimalParagraph:
    """Minimal paragraf objesi"""
    def __init__(self, text):
        self.text = text

class WordReaderService:
    """GÃ¼ncellenmiÅŸ Word Reader Service - Headerless desteÄŸi ile"""
    
    def __init__(self):
        self.current_document = None
        self.headerless_reader = HeaderlessWordReader()

    def load_document(self, file_path: str) -> bool:
        """Word DosyasÄ±nÄ± YÃ¼kler - HeaderLess fallback ile"""
        try:
            # Ã–nce normal yÃ¼klemeyi dene
            doc = Document(file_path)
            self.current_document = doc
            print(f"âœ“ Normal Word dosyasÄ± yÃ¼klendi: {file_path}")
            return True
            
        except Exception as e:
            error_msg = str(e).lower()
            print(f"âš  Normal yÃ¼kleme baÅŸarÄ±sÄ±z: {e}")
            
            # SharePoint/Header problemi mi?
            if any(keyword in error_msg for keyword in ['header', 'footer', 'relationship', 'null']):
                print("ğŸ”§ Header/Footer problemi tespit edildi, headerless yÃ¼kleme deneniyor...")
                
                # Headerless yÃ¼kleme
                success = self.headerless_reader.load_document_without_headers(file_path)
                if success:
                    self.current_document = self.headerless_reader.current_document
                    print("âœ“ Headerless yÃ¼kleme baÅŸarÄ±lÄ±")
                    return True
                else:
                    print("âœ— Headerless yÃ¼kleme de baÅŸarÄ±sÄ±z")
                    return False
            else:
                print(f"HATA: Bilinmeyen Word hatasÄ±: {e}")
                return False

    def extract_tables(self, file_path: str) -> List:
        """Word iÃ§erisindeki TablolarÄ± Veri Toplar - HeaderLess desteÄŸi ile"""
        print("Veri iÅŸleme baÅŸlÄ±yor (HeaderLess desteÄŸi ile)...")
        
        # Header'Ä± ilk eleman olarak liste iÃ§inde tanÄ±mla
        headers = ["ITEM NO", "DIMENSION", "ACTUAL", "BADGE", "TOOLING", "REMARKS", "B/P ZONE", "INSP. LEVEL"]
        extracted_data = [headers]
        
        try:
            # Word dokÃ¼manÄ±nÄ± yÃ¼kle (HeaderLess fallback ile)
            if not self.load_document(file_path):
                print("HATA: Word dosyasÄ± yÃ¼klenemedi")
                return []
            
            tables = self.current_document.tables
            print(f"  {len(tables)} tablo bulundu")
            
            for table_idx, table in enumerate(tables):
                print(f"  Tablo {table_idx + 1} iÅŸleniyor...")
                
                for row in table.rows:
                    row_data = []
                    for cell in row.cells:
                        # HÃ¼credeki tÃ¼m paragraflarÄ± birleÅŸtir
                        if hasattr(cell, 'paragraphs'):
                            cell_text = '\n'.join([p.text for p in cell.paragraphs])
                        else:
                            # MinimalCell iÃ§in
                            cell_text = cell.text
                        row_data.append(cell_text)
                    
                    # DEBUG: SatÄ±r verilerini kontrol et
                    if len(row_data) > 0:
                        print(f"    Debug - Ä°lk element: '{row_data[0][:30]}...'")

                        def char_check():
                            control = []
                            for listeler in extracted_data:
                                result = row_data[0] in listeler
                                control.append(str(result))
                            return "True" in control
                    
                    # Filtreleme mantÄ±ÄŸÄ± (aynÄ±)
                    if (len(row_data) > 4 and not (
                        row_data[1].strip().endswith(("Inch", "Inches")) or
                        row_data[0].strip().endswith(("ITEM NO KC", "ITEM NO", "RECORDING", "INSPECTION", "INSPECTOR", "/0", "**", "PAGE NO")) or
                        char_check())):
                        
                        row_data[1] = row_data[1].replace(",", ".")
                        
                        # SatÄ±rÄ± 8 kolona pad et veya kÄ±rp
                        padded_row = row_data + [''] * (len(headers) - len(row_data))
                        padded_row = padded_row[:len(headers)]
                        
                        extracted_data.append(padded_row)
                        print(f"    âœ“ SatÄ±r eklendi: {row_data[0][:20]}... (kolon sayÄ±sÄ±: {len(padded_row)})")
            
            print(f"âœ“ Toplam {len(extracted_data) - 1} karakter Ã§Ä±karÄ±ldÄ±")
            return extracted_data
            
        except Exception as e:
            print(f"HATA: Tablo Ã§Ä±karma iÅŸleminde sorun: {e}")
            import traceback
            traceback.print_exc()
            return []

# Test fonksiyonu
def test_headerless_word_reader():
    """HeaderLess Word Reader'Ä± test eder"""
    test_file = "problematic_sharepoint.docx"
    
    if not os.path.exists(test_file):
        print("Test dosyasÄ± bulunamadÄ±")
        return
    
    print("=== HEADERLESS WORD READER TEST ===")
    
    # Test et
    word_service = WordReaderService()
    data = word_service.extract_tables(test_file)
    
    print(f"\nâœ“ SonuÃ§:")
    print(f"  - Ã‡Ä±karÄ±lan satÄ±r sayÄ±sÄ±: {len(data) - 1 if data else 0}")
    print(f"  - Header: {data[0] if data else 'Yok'}")
    if len(data) > 1:
        print(f"  - Ä°lk veri satÄ±rÄ±: {data[1]}")

if __name__ == "__main__":
    test_headerless_word_reader()
